/*
Copyright 2022 Citrix Systems, Inc
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"testing"

	"github.com/citrix/citrix-xds-adaptor/tests/env"
)

func createDir(dir string) error {
	var _, err = os.Stat(dir)
	if os.IsNotExist(err) {
		err = os.Mkdir(dir, 0700)
		if err != nil {
			fmt.Printf("Could not create the config directory %s", dir)
			return err
		}
	}
	return nil
}
func Test_getVserverIP(t *testing.T) {
	testCases := []struct {
		inputVserverIP string
		expectedOutput string
		expecterError  string
	}{
		{"65.1.1.1", "65.1.1.1", ""},
		{"127.0.0.1", "127.0.0.1", ""},
		{"192.145.6.78", "192.145.6.78", ""},
		{"", "", ""},
		{"nsip", "nsip", ""},
		{"123.1", "", "Not a valid IP address"},
		{"444", "", "Not a valid IP address"},
		{"fe80:8", "", "Not a valid IP address"},
		{"fe80::90", "", "Not a valid IPv4 address"},
		{"123:1::45", "", "Not a valid IPv4 address"},
	}

	for _, c := range testCases {
		vip, err := getVserverIP(c.inputVserverIP)
		if err == nil && c.expecterError != "" {
			t.Errorf("incorrect evaluation of '%s': expected failure '%s', but recevied success", c.inputVserverIP, c.expecterError)
		} else if err != nil && c.expecterError == "" {
			t.Errorf("incorrect evaluation of '%s': expected success, but received error '%v'", c.inputVserverIP, err)
		} else if err != nil && err.Error() != c.expecterError {
			t.Errorf("incorrect evaluation of '%s': expected error '%v' but got error '%v'", c.inputVserverIP, fmt.Errorf(c.expecterError), err)
		}
		if vip != c.expectedOutput {
			t.Errorf("incorrect evaluation of '%s': expected output '%s' but got '%s'", c.inputVserverIP, c.expectedOutput, vip)
		}
	}
}

func Test_getUserName(t *testing.T) {
	type EI struct {
		userFile string
	}

	type EO struct {
		userName string
		err      string
	}
	t.Log("Unit test of getUserName func")
	// Create some files
	var fnContent = map[string]string{
		"user1.txt": "user1",
		"user2.txt": "user2",
	}
	for fn, content := range fnContent {
		err := env.CreateAndWriteFile(fn, content)
		if err != nil {
			t.Fatalf("Could not create file %s. Error: %s", fn, err.Error())
		}
	}

	testCases := map[string]struct {
		input          EI
		expectedOutput EO
	}{
		"File not present": {
			input:          EI{"/tmp/userfile"},
			expectedOutput: EO{"", "open /tmp/userfile: no such file or directory"},
		},
		"File not provided": {
			input:          EI{""},
			expectedOutput: EO{"envuser", ""},
		},
		"File provided": {
			input:          EI{"user1.txt"},
			expectedOutput: EO{"user1", ""},
		},
		"No file No env var": {
			input:          EI{""},
			expectedOutput: EO{"nsroot", ""},
		},
	}

	for id, c := range testCases {
		if id == "No file No env var" {
			os.Setenv("NS_USER", "")
		} else {
			os.Setenv("NS_USER", "envuser")
		}
		userName, err := getUserName(c.input.userFile)
		if err == nil && len(c.expectedOutput.err) > 0 {
			t.Errorf("inputfile: %s. Expected Error %s but received Success", c.input.userFile, c.expectedOutput.err)
		} else if err != nil && err.Error() != c.expectedOutput.err {
			t.Errorf("inputfile: %s. Expected Error %s but Actual error %v", c.input.userFile, c.expectedOutput.err, err)
		} else if err != nil && len(c.expectedOutput.err) == 0 {
			t.Errorf("inputfile: %s. Expected Success but received error %v", c.input.userFile, err)
		}

		if userName != c.expectedOutput.userName {
			t.Errorf("inputfile: %s. Expected username: %s. Received Username: %s", c.input.userFile, c.expectedOutput.userName, userName)
		} else {
			t.Logf("inputfile: %s. Success!", c.input.userFile)
		}
	}
	// Delete files
	for fn := range fnContent {
		err := env.DeleteFile(fn)
		if err != nil {
			t.Errorf("Could not delete file %s. Error: %s", fn, err.Error())
		}
	}
}

func Test_getPassword(t *testing.T) {
	type EI struct {
		passFile string
	}

	type EO struct {
		passWord string
		err      string
	}
	t.Log("Unit test of getPassword func")
	// Set Environment variables password

	// Create a directory where cpx autogenerated password is stored
	if err := createDir("/var/deviceinfo"); err != nil {
		t.Fatalf("Could not create /var/deviceinfo directory. Error: %s", err.Error())
	}
	defaultp := "non-default"
	cpxpwfile := "/var/deviceinfo/random_id"
	bkpwfile := "/var/deviceinfo/random_id.bak"
	if _, err := os.Stat(cpxpwfile); err == nil {
		_ = os.Rename(cpxpwfile, bkpwfile)
		t.Logf("Backupfile created")
	}
	// Create some files
	var fnContent = map[string]string{
		"pass1.txt": "pass1",
		cpxpwfile:   "nondefaultpasswordforcpx",
	}
	for fn, content := range fnContent {
		if fn == cpxpwfile { // Skip this file creation for now
			continue
		}
		err := env.CreateAndWriteFile(fn, content)
		if err != nil {
			t.Fatalf("Could not create file %s. Error: %s", fn, err.Error())
		}
	}

	testCases := map[string]struct {
		input          EI
		expectedOutput EO
	}{
		"Password file neither exist, nor created But env var set": {
			input:          EI{"/tmp/passfile"},
			expectedOutput: EO{defaultp, ""},
		},
		"Password file not given": {
			input:          EI{""},
			expectedOutput: EO{defaultp, ""},
		},
		"Password file exists": {
			input:          EI{"pass1.txt"},
			expectedOutput: EO{"pass1", ""},
		},
		"CPX Password file presents": {
			input:          EI{cpxpwfile},
			expectedOutput: EO{"nondefaultpasswordforcpx", ""},
		},
		"No file no env": {
			input:          EI{""},
			expectedOutput: EO{"", "password file not created/mounted"},
		},
	}

	for id, c := range testCases {
		if c.input.passFile == cpxpwfile {
			_ = env.CreateAndWriteFile(cpxpwfile, fnContent[cpxpwfile])
		}
		if id == "No file no env" {
			os.Setenv("NS_PASSWORD", "")
		} else {
			os.Setenv("NS_PASSWORD", defaultp)
		}
		passWord, err := getPassword(c.input.passFile)
		if err == nil && len(c.expectedOutput.err) > 0 {
			t.Errorf("%s: Expected Error %s but received Success", id, c.expectedOutput.err)
		} else if err != nil && err.Error() != c.expectedOutput.err {
			t.Errorf("%s: Expected Error \"%s\" but Actual error \"%s\"", id, c.expectedOutput.err, err.Error())
		} else if err != nil && len(c.expectedOutput.err) == 0 {
			t.Errorf("%s: Expected Success but received error %v", id, err)
		}

		if passWord != c.expectedOutput.passWord {
			t.Errorf("%s: Expected password: %s. Received password: %s", id, c.expectedOutput.passWord, passWord)
		} else {
			t.Logf("%s: Success!", id)
		}
	}
	// Restore /var/deviceinfo/random_id file
	if _, err := os.Stat(bkpwfile); err == nil {
		_ = os.Rename(bkpwfile, cpxpwfile)
		t.Logf("password file restored")
		pass, _ := ioutil.ReadFile(cpxpwfile)
		t.Logf("Password: %s\n", string(pass))
		_ = env.DeleteFile(bkpwfile)
	}

	// Delete files
	for fn := range fnContent {
		if fn == cpxpwfile {
			continue
		}
		err := env.DeleteFile(fn)
		if err != nil {
			t.Errorf("Could not delete file %s. Error: %s", fn, err.Error())
		}
	}
}
